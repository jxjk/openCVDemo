# 图纸检测部位预先标定实现方案（IT8级精度版）

## 一、概述

图纸检测部位预先标定是指在开始实际检测前，通过图纸信息预先设定需要检测的部位、尺寸类型、公差要求等参数，实现自动化检测配置。标定过程包括图纸解析、检测部位标注、参数配置、模板生成等步骤。

**精度目标：** IT8级（中等高精度）

**核心技术：** 亚像素级检测算法（1/20像素精度）

---

## 二、2D图纸检测部位标定

### 2.1 标定流程

```
图纸导入 → 图纸解析 → 检测部位标注 → 参数配置 → 模板保存
    ↓         ↓          ↓          ↓          ↓
  识别格式   提取信息   标记ROI    设定公差   生成配置
```

### 2.2 实现方案

#### 方案一：基于CAD文件直接解析

**适用场景：** 有原始CAD文件（DWG/DXF/SVG格式）

**实现步骤：**

1. **CAD文件解析**
   ```python
   import ezdxf  # 用于解析DXF文件
   import svgpathtools  # 用于解析SVG文件

   def parse_dxf_file(dxf_path):
       """解析DXF文件，提取几何信息"""
       doc = ezdxf.readfile(dxf_path)
       msp = doc.modelspace()

       entities = []
       for entity in msp:
           if entity.dxftype() == 'CIRCLE':
               entities.append({
                   'type': 'circle',
                   'center': (entity.dxf.center.x, entity.dxf.center.y),
                   'radius': entity.dxf.radius
               })
           elif entity.dxftype() == 'LINE':
               entities.append({
                   'type': 'line',
                   'start': (entity.dxf.start[0], entity.dxf.start[1]),
                   'end': (entity.dxf.end[0], entity.dxf.end[1])
               })
           elif entity.dxftype() in ['ARC', 'LWPOLYLINE']:
               # 处理其他几何实体
               pass

       return entities
   ```

2. **尺寸标注提取**
   ```python
   def extract_dimensions(doc):
       """提取尺寸标注信息"""
       dimensions = []
       msp = doc.modelspace()

       for entity in msp:
           if entity.dxftype() == 'DIMENSION':
               dim_data = {
                   'type': 'dimension',
                   'dimension_type': entity.dxf.dimtype,
                   'text': entity.dxf.text if hasattr(entity, 'dxf') else '',
                   'definition_points': get_dim_points(entity)
               }
               dimensions.append(dim_data)

       return dimensions
   ```

3. **自动识别检测部位**
   ```python
   def auto_identify_features(entities, dimensions):
       """自动识别需要检测的特征"""
       features = []

       # 根据尺寸标注识别需要测量的部位
       for dim in dimensions:
           if 'diameter' in dim['text'].lower() or 'φ' in dim['text']:
               features.append({
                   'feature_type': 'diameter',
                   'location': find_associated_circle(dim, entities),
                   'nominal_value': extract_value(dim['text']),
                   'tolerance': 'IT11'
               })
           elif 'length' in dim['text'].lower() or '⌐' in dim['text']:
               features.append({
                   'feature_type': 'length',
                   'location': find_associated_line(dim, entities),
                   'nominal_value': extract_value(dim['text']),
                   'tolerance': 'IT11'
               })

       return features
   ```

4. **生成检测模板**
   ```python
   import json

   def generate_inspection_template(features, output_path):
       """生成检测模板配置文件"""
       template = {
           'version': '1.0',
           'created_date': '2026-02-09',
           'features': features,
           'tolerance_standard': 'IT11'
       }

       with open(output_path, 'w', encoding='utf-8') as f:
           json.dump(template, f, indent=2, ensure_ascii=False)
   ```

---

#### 方案二：基于图像的手动标注

**适用场景：** 只有PDF或图片格式的图纸

**实现步骤：**

1. **图纸图像显示**
   ```python
   import cv2
   import numpy as np
   from PyQt5.QtWidgets import (QMainWindow, QLabel, QPushButton,
                                 QVBoxLayout, QWidget, QGraphicsView,
                                 QGraphicsScene, QGraphicsPixmapItem)
   from PyQt5.QtCore import Qt, QPointF
   from PyQt5.QtGui import QPixmap, QImage, QPainter, QPen, QColor

   class DrawingAnnotationTool(QMainWindow):
       def __init__(self):
           super().__init__()
           self.setWindowTitle("图纸检测部位标注工具")
           self.setGeometry(100, 100, 1200, 800)

           # 主布局
           main_widget = QWidget()
           self.setCentralWidget(main_widget)
           layout = QVBoxLayout(main_widget)

           # 图像显示区域
           self.scene = QGraphicsScene()
           self.view = QGraphicsView(self.scene)
           self.view.setRenderHint(QPainter.Antialiasing)
           layout.addWidget(self.view)

           # 工具栏
           toolbar = QWidget()
           toolbar_layout = QVBoxLayout(toolbar)

           # 标注类型按钮
           self.circle_btn = QPushButton("标注直径")
           self.length_btn = QPushButton("标注长度")
           self.width_btn = QPushButton("标注宽度")
           self.save_btn = QPushButton("保存模板")

           toolbar_layout.addWidget(self.circle_btn)
           toolbar_layout.addWidget(self.length_btn)
           toolbar_layout.addWidget(self.width_btn)
           toolbar_layout.addWidget(self.save_btn)

           layout.addWidget(toolbar)

           # 状态变量
           self.current_tool = None
           self.annotations = []
           self.drawing_points = []

           # 连接信号
           self.circle_btn.clicked.connect(lambda: self.set_tool('circle'))
           self.length_btn.clicked.connect(lambda: self.set_tool('length'))
           self.width_btn.clicked.connect(lambda: self.set_tool('width'))
           self.save_btn.clicked.connect(self.save_template)

           self.view.mousePressEvent = self.on_mouse_press
           self.view.mouseMoveEvent = self.on_mouse_move
           self.view.mouseReleaseEvent = self.on_mouse_release

       def load_image(self, image_path):
           """加载图纸图像"""
           self.image = cv2.imread(image_path)
           height, width = self.image.shape[:2]
           bytes_per_line = 3 * width
           q_img = QImage(self.image.data, width, height,
                         bytes_per_line, QImage.Format_RGB888)
           pixmap = QPixmap.fromImage(q_img)

           self.pixmap_item = QGraphicsPixmapItem(pixmap)
           self.scene.addItem(self.pixmap_item)

       def set_tool(self, tool_type):
           """设置当前标注工具"""
           self.current_tool = tool_type
           self.drawing_points = []

       def on_mouse_press(self, event):
           """鼠标按下事件"""
           if self.current_tool == 'circle':
               # 圆形标注需要两个点：圆心和边缘点
               pos = self.view.mapToScene(event.pos())
               self.drawing_points.append(QPointF(pos.x(), pos.y()))

               if len(self.drawing_points) == 2:
                   self.add_circle_annotation()

           elif self.current_tool in ['length', 'width']:
               # 线性标注需要两个点：起点和终点
               pos = self.view.mapToScene(event.pos())
               self.drawing_points.append(QPointF(pos.x(), pos.y()))

               if len(self.drawing_points) == 2:
                   self.add_line_annotation()

       def add_circle_annotation(self):
           """添加圆形标注"""
           center = self.drawing_points[0]
           edge = self.drawing_points[1]

           radius = ((edge.x() - center.x())**2 +
                    (edge.y() - center.y())**2)**0.5

           # 绘制圆形标注
           ellipse = QGraphicsEllipseItem(center.x() - radius,
                                          center.y() - radius,
                                          radius * 2, radius * 2)
           ellipse.setPen(QPen(QColor(0, 255, 0), 2))
           self.scene.addItem(ellipse)

           # 记录标注信息
           self.annotations.append({
               'type': 'diameter',
               'center': (center.x(), center.y()),
               'radius': radius,
               'nominal_value': 0,  # 需要用户输入
               'tolerance': 'IT11'
           })

           self.drawing_points = []

       def add_line_annotation(self):
           """添加线性标注"""
           start = self.drawing_points[0]
           end = self.drawing_points[1]

           # 绘制线段标注
           line = QGraphicsLineItem(start.x(), start.y(),
                                    end.x(), end.y())
           line.setPen(QPen(QColor(255, 0, 0), 2))
           self.scene.addItem(line)

           # 计算长度
           length = ((end.x() - start.x())**2 +
                    (end.y() - start.y())**2)**0.5

           # 记录标注信息
           self.annotations.append({
               'type': 'length' if self.current_tool == 'length' else 'width',
               'start': (start.x(), start.y()),
               'end': (end.x(), end.y()),
               'length': length,
               'nominal_value': 0,  # 需要用户输入
               'tolerance': 'IT11'
           })

           self.drawing_points = []

       def save_template(self):
           """保存标注模板"""
           template = {
               'version': '1.0',
               'created_date': '2026-02-09',
               'image_scale': 1.0,  # 需要标定
               'annotations': self.annotations,
               'tolerance_standard': 'IT11'
           }

           output_path = "inspection_template.json"
           with open(output_path, 'w', encoding='utf-8') as f:
               json.dump(template, f, indent=2, ensure_ascii=False)

           print(f"模板已保存到: {output_path}")
   ```

2. **参数配置对话框**
   ```python
   from PyQt5.QtWidgets import QDialog, QLineEdit, QFormLayout, QDialogButtonBox

   class ParameterConfigDialog(QDialog):
       def __init__(self, annotation_data, parent=None):
           super().__init__(parent)
           self.setWindowTitle("参数配置")
           self.annotation_data = annotation_data

           layout = QFormLayout(self)

           # 标称值输入
           self.nominal_edit = QLineEdit()
           self.nominal_edit.setText(str(annotation_data.get('nominal_value', 0)))
           layout.addRow("标称值 (mm):", self.nominal_edit)

           # 公差等级选择
           self.tolerance_combo = QLineEdit()
           self.tolerance_combo.setText(annotation_data.get('tolerance', 'IT11'))
           layout.addRow("公差等级:", self.tolerance_combo)

           # 按钮
           buttons = QDialogButtonBox(
               QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
           buttons.accepted.connect(self.accept)
           buttons.rejected.connect(self.reject)
           layout.addRow(buttons)

       def get_parameters(self):
           """获取配置的参数"""
           return {
               'nominal_value': float(self.nominal_edit.text()),
               'tolerance': self.tolerance_combo.text()
           }
   ```

3. **像素-毫米标定**
   ```python
   def calibrate_pixel_scale(self, reference_length_mm):
       """像素-毫米标定"""
       # 方法1：使用标定板
       calibration_board_image = cv2.imread('calibration_board.jpg')

       # 检测标定板上的已知特征（如圆形标记）
       circles = cv2.HoughCircles(
           calibration_board_image, cv2.HOUGH_GRADIENT, 1, 20,
           param1=50, param2=30, minRadius=10, maxRadius=100
       )

       if circles is not None:
           # 计算像素直径
           pixel_diameter = circles[0][0][2] * 2

           # 计算比例尺
           self.pixel_to_mm_ratio = reference_length_mm / pixel_diameter
           print(f"标定比例: 1像素 = {self.pixel_to_mm_ratio:.4f}mm")

       # 方法2：手动输入
       # pixel_distance = get_user_input_pixel_distance()
       # mm_distance = get_user_input_mm_distance()
       # self.pixel_to_mm_ratio = mm_distance / pixel_distance
   ```

---

### 2.3 标定结果应用

```python
class InspectionEngine:
    def __init__(self, template_path):
        with open(template_path, 'r', encoding='utf-8') as f:
            self.template = json.load(f)
        self.pixel_to_mm_ratio = 0.01  # 默认值，需要标定

    def inspect_part(self, image):
        """根据模板检测零件"""
        results = []

        for annotation in self.template['annotations']:
            if annotation['type'] == 'diameter':
                result = self.measure_diameter(image, annotation)
                results.append(result)
            elif annotation['type'] == 'length':
                result = self.measure_length(image, annotation)
                results.append(result)

        return results

    def measure_diameter(self, image, annotation):
        """测量直径"""
        # 在指定区域检测圆形
        roi = self.extract_roi(image, annotation)

        # 边缘检测
        edges = cv2.Canny(roi, 50, 150)

        # 霍夫圆检测
        circles = cv2.HoughCircles(
            edges, cv2.HOUGH_GRADIENT, 1, 20,
            param1=50, param2=30, minRadius=10, maxRadius=100
        )

        if circles is not None:
            circle = circles[0][0]
            pixel_diameter = circle[2] * 2
            mm_diameter = pixel_diameter * self.pixel_to_mm_ratio

            # 计算公差
            tolerance = self.get_tolerance(mm_diameter, annotation['tolerance'])

            return {
                'feature_type': 'diameter',
                'measured_value': mm_diameter,
                'nominal_value': annotation['nominal_value'],
                'tolerance': tolerance,
                'is_within_tolerance': abs(mm_diameter - annotation['nominal_value']) <= tolerance,
                'center': (circle[0], circle[1])
            }

    def measure_length(self, image, annotation):
        """测量长度"""
        # 在指定区域检测边缘
        roi = self.extract_roi(image, annotation)

        # 边缘检测
        edges = cv2.Canny(roi, 50, 150)

        # 寻找轮廓
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)

        if contours:
            # 获取最小外接矩形
            rect = cv2.minAreaRect(contours[0])
            box = cv2.boxPoints(rect)
            box = np.int0(box)

            # 计算长宽
            width = np.linalg.norm(box[0] - box[1])
            height = np.linalg.norm(box[1] - box[2])

            pixel_length = max(width, height)
            mm_length = pixel_length * self.pixel_to_mm_ratio

            # 计算公差
            tolerance = self.get_tolerance(mm_length, annotation['tolerance'])

            return {
                'feature_type': 'length',
                'measured_value': mm_length,
                'nominal_value': annotation['nominal_value'],
                'tolerance': tolerance,
                'is_within_tolerance': abs(mm_length - annotation['nominal_value']) <= tolerance
            }

    def get_tolerance(self, nominal_value, tolerance_grade='IT8'):
        """根据IT8标准获取公差值"""
        # IT8公差表
        tolerance_table = {
            (1, 3): 0.014,
            (3, 6): 0.018,
            (6, 10): 0.022,
            (10, 18): 0.027,
            (18, 30): 0.033,
            (30, 40): 0.039
        }

        for (min_val, max_val), tolerance in tolerance_table.items():
            if min_val < nominal_value <= max_val:
                return tolerance

        return 0.0  # 超出范围
```

---

## 三、3D图纸检测部位标定

### 3.1 标定流程

```
3D模型导入 → 模型解析 → 检测面/特征标注 → 参数配置 → 模板保存
    ↓         ↓          ↓          ↓          ↓
  识别格式   提取几何   标记3D ROI  设定公差   生成配置
```

### 3.2 实现方案

#### 方案一：基于3D CAD模型解析

**适用场景：** 有原始3D CAD文件（STEP/IGES/STL格式）

**实现步骤：**

1. **3D模型解析（使用FreeCAD）**
   ```python
   import FreeCAD
   import Part

   def parse_step_file(step_path):
       """解析STEP文件，提取3D几何信息"""
       doc = FreeCAD.newDocument()
       Part.import(doc, step_path)

       features = []

       # 遍历所有对象
       for obj in doc.Objects:
           if hasattr(obj, 'Shape'):
               shape = obj.Shape

               # 提取面信息
               for face in shape.Faces:
                   if face.Surface.TypeId == 'Part::GeomCylinder':
                       # 圆柱面 - 可能是直径检测部位
                       features.append({
                           'type': 'cylinder_face',
                           'center': face.Surface.Center,
                           'radius': face.Surface.Radius,
                           'axis': face.Surface.Axis,
                           'area': face.Area
                       })
                   elif face.Surface.TypeId == 'Part::GeomPlane':
                       # 平面 - 可能是长度/宽度检测部位
                       features.append({
                           'type': 'planar_face',
                           'location': face.Surface.Position,
                           'normal': face.Surface.Axis,
                           'area': face.Area
                       })

               # 提取边信息
               for edge in shape.Edges:
                   if isinstance(edge.Curve, Part.Circle):
                       # 圆边
                       features.append({
                           'type': 'circular_edge',
                           'center': edge.Curve.Center,
                           'radius': edge.Curve.Radius
                       })

       return features
   ```

2. **尺寸标注提取**
   ```python
   def extract_3d_dimensions(doc):
       """提取3D尺寸标注（如果CAD文件包含PMI信息）"""
       dimensions = []

       # 尝试读取PMI (Product Manufacturing Information) 数据
       for obj in doc.Objects:
           if 'Annotation' in obj.Name:
               # 处理标注对象
               pass

       return dimensions
   ```

3. **3D检测部位标注工具**
   ```python
   import vtk
   from vtk.qt.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor
   from PyQt5.QtWidgets import QMainWindow, QVBoxLayout, QWidget, QPushButton
   from PyQt5.QtCore import Qt

   class Drawing3DAnnotationTool(QMainWindow):
       def __init__(self):
           super().__init__()
           self.setWindowTitle("3D图纸检测部位标注工具")
           self.setGeometry(100, 100, 1400, 900)

           # 主布局
           main_widget = QWidget()
           self.setCentralWidget(main_widget)
           layout = QVBoxLayout(main_widget)

           # VTK渲染窗口
           self.vtkWidget = QVTKRenderWindowInteractor(main_widget)
           layout.addWidget(self.vtkWidget)

           # 工具栏
           toolbar = QWidget()
           toolbar_layout = QVBoxLayout(toolbar)

           self.load_btn = QPushButton("加载3D模型")
           self.face_btn = QPushButton("标注面")
           self.edge_btn = QPushButton("标注边")
           self.save_btn = QPushButton("保存模板")

           toolbar_layout.addWidget(self.load_btn)
           toolbar_layout.addWidget(self.face_btn)
           toolbar_layout.addWidget(self.edge_btn)
           toolbar_layout.addWidget(self.save_btn)

           layout.addWidget(toolbar)

           # VTK初始化
           self.renderer = vtk.vtkRenderer()
           self.vtkWidget.GetRenderWindow().AddRenderer(self.renderer)
           self.interactor = self.vtkWidget.GetRenderWindow().GetInteractor()

           # 标注列表
           self.annotations = []
           self.picker = vtk.vtkCellPicker()

           # 连接信号
           self.load_btn.clicked.connect(self.load_3d_model)
           self.face_btn.clicked.connect(lambda: self.set_tool('face'))
           self.edge_btn.clicked.connect(lambda: self.set_tool('edge'))
           self.save_btn.clicked.connect(self.save_template)

           # 设置交互
           self.interactor.SetPicker(self.picker)
           self.interactor.AddObserver("LeftButtonPressEvent", self.on_click)

           self.current_tool = None

       def load_3d_model(self, model_path):
           """加载3D模型"""
           # 根据文件格式选择读取器
           if model_path.endswith('.stl'):
               reader = vtk.vtkSTLReader()
           elif model_path.endswith('.obj'):
               reader = vtk.vtkOBJReader()
           else:
               print("不支持的文件格式")
               return

           reader.SetFileName(model_path)
           reader.Update()

           # 创建映射器和Actor
           mapper = vtk.vtkPolyDataMapper()
           mapper.SetInputConnection(reader.GetOutputPort())

           actor = vtk.vtkActor()
           actor.SetMapper(mapper)
           actor.GetProperty().SetColor(0.8, 0.8, 0.8)

           # 添加到渲染器
           self.renderer.AddActor(actor)
           self.renderer.ResetCamera()
           self.interactor.Initialize()
           self.interactor.Start()

       def set_tool(self, tool_type):
           """设置当前标注工具"""
           self.current_tool = tool_type

       def on_click(self, obj, event):
           """鼠标点击事件"""
           if self.current_tool is None:
               return

           # 获取点击位置
           click_pos = self.interactor.GetEventPosition()

           # 使用选择器拾取
           self.picker.Pick(click_pos[0], click_pos[1], 0, self.renderer)

           if self.picker.GetCellId() >= 0:
               if self.current_tool == 'face':
                   self.annotate_face()
               elif self.current_tool == 'edge':
                   self.annotate_edge()

       def annotate_face(self):
           """标注面"""
           # 获取选中的面
           cell_id = self.picker.GetCellId()
           poly_data = self.picker.GetDataSet()

           # 计算面的中心和法向量
           cell = poly_data.GetCell(cell_id)
           points = cell.GetPoints()

           center = [0, 0, 0]
           for i in range(points.GetNumberOfPoints()):
               point = points.GetPoint(i)
               center[0] += point[0]
               center[1] += point[1]
               center[2] += point[2]

           center = [c / points.GetNumberOfPoints() for c in center]

           # 记录标注
           self.annotations.append({
               'type': 'face',
               'cell_id': cell_id,
               'center': center,
               'feature_type': 'unknown',  # 需要进一步判断
               'nominal_value': 0,
               'tolerance': 'IT11'
           })

           # 添加高亮显示
           highlight_actor = self.create_highlight_actor(poly_data, cell_id)
           self.renderer.AddActor(highlight_actor)
           self.vtkWidget.GetRenderWindow().Render()

       def annotate_edge(self):
           """标注边"""
           cell_id = self.picker.GetCellId()
           poly_data = self.picker.GetDataSet()

           cell = poly_data.GetCell(cell_id)
           points = cell.GetPoints()

           # 获取边的起点和终点
           start_point = points.GetPoint(0)
           end_point = points.GetPoint(1)

           # 计算边长
           import numpy as np
           edge_length = np.linalg.norm(np.array(end_point) - np.array(start_point))

           # 记录标注
           self.annotations.append({
               'type': 'edge',
               'cell_id': cell_id,
               'start_point': start_point,
               'end_point': end_point,
               'length': edge_length,
               'nominal_value': 0,
               'tolerance': 'IT11'
           })

       def create_highlight_actor(self, poly_data, cell_id):
           """创建高亮显示Actor"""
           # 提取单个面
           extraction = vtk.vtkExtractCells()
           extraction.SetInputData(poly_data)
           extraction.SetCellList([cell_id])
           extraction.Update()

           mapper = vtk.vtkPolyDataMapper()
           mapper.SetInputConnection(extraction.GetOutputPort())

           actor = vtk.vtkActor()
           actor.SetMapper(mapper)
           actor.GetProperty().SetColor(1, 0, 0)
           actor.GetProperty().SetOpacity(0.7)

           return actor

       def save_template(self):
           """保存3D标注模板"""
           template = {
               'version': '1.0',
               'created_date': '2026-02-09',
               'dimension': '3D',
               'annotations': self.annotations,
               'tolerance_standard': 'IT11'
           }

           output_path = "inspection_template_3d.json"
           with open(output_path, 'w', encoding='utf-8') as f:
               json.dump(template, f, indent=2, ensure_ascii=False)

           print(f"3D模板已保存到: {output_path}")
   ```

---

#### 方案二：3D视觉检测标定

**适用场景：** 通过3D视觉传感器进行实际检测

**实现步骤：**

1. **相机-工作空间标定**
   ```python
   def calibrate_3d_camera():
       """3D相机标定"""
       # 使用标定板进行标定
       import cv2
       import numpy as np

       # 准备标定板图像
       calibration_images = []

       # 棋盘格参数
       board_size = (9, 6)  # 内角点数量
       square_size = 1.0  # mm

       # 检测角点
       obj_points = []  # 3D世界坐标
       img_points = []  # 2D图像坐标

       objp = np.zeros((board_size[0] * board_size[1], 3), np.float32)
       objp[:, :2] = np.mgrid[0:board_size[0],
                               0:board_size[1]].T.reshape(-1, 2)
       objp *= square_size

       for img in calibration_images:
           gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
           ret, corners = cv2.findChessboardCorners(gray, board_size, None)

           if ret:
               obj_points.append(objp)
               img_points.append(corners)

       # 相机标定
       ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(
           obj_points, img_points, gray.shape[::-1], None, None
       )

       # 计算重投影误差
       mean_error = 0
       for i in range(len(obj_points)):
           img_points_reproj, _ = cv2.projectPoints(
               obj_points[i], rvecs[i], tvecs[i], mtx, dist
           )
           error = cv2.norm(img_points[i], img_points_reproj,
                           cv2.NORM_L2) / len(img_points_reproj)
           mean_error += error

       mean_error /= len(obj_points)

       return {
           'camera_matrix': mtx,
           'distortion_coefficients': dist,
           'reprojection_error': mean_error
       }
   ```

2. **手眼标定**
   ```python
   def hand_eye_calibration():
       """手眼标定（相机-机械臂）"""
       import cv2
       import numpy as np

       # 准备数据
       # R_gripper2base: 机械臂末端到基座的旋转矩阵
       # t_gripper2base: 机械臂末端到基座的平移向量
       # R_target2cam: 标定板到相机的旋转矩阵
       # t_target2cam: 标定板到相机的平移向量

       R_gripper2base = []  # 机械臂姿态列表
       t_gripper2base = []
       R_target2cam = []    # 相机姿态列表
       t_target2cam = []

       # 执行手眼标定
       R_cam2gripper, t_cam2gripper = cv2.calibrateHandEye(
           R_gripper2base, t_gripper2base,
           R_target2cam, t_target2cam,
           method=cv2.CALIB_HAND_EYE_TSAI
       )

       return {
           'R_cam2gripper': R_cam2gripper,
           't_cam2gripper': t_cam2gripper
       }
   ```

3. **3D测量实现**
   ```python
   def measure_3d_feature(point_cloud, feature_info):
       """3D特征测量"""
       import open3d as o3d
       import numpy as np

       # 转换为Open3D点云
       pcd = o3d.geometry.PointCloud()
       pcd.points = o3d.utility.Vector3dVector(point_cloud)

       if feature_info['type'] == 'cylinder':
           # 拟合圆柱
           cylinder_model, inliers = pcd.segment_plane(
               distance_threshold=0.01,
               ransac_n=3,
               num_iterations=1000
           )

           # 提取直径
           diameter = cylinder_model.diameter * 2
           return diameter

       elif feature_info['type'] == 'plane_distance':
           # 计算两个平面之间的距离
           # ...

       elif feature_info['type'] == 'edge_length':
           # 计算边长
           # ...

       return None
   ```

---

## 四、标定数据管理

### 4.1 模板数据结构

```python
{
    "version": "2.0",
    "created_date": "2026-02-09",
    "modified_date": "2026-02-09",
    "drawing_info": {
        "file_name": "part001.dwg",
        "file_path": "/drawings/part001.dwg",
        "drawing_number": "DWG-001",
        "revision": "A"
    },
    "calibration_info": {
        "pixel_to_mm_ratio": 0.0125,
        "calibration_date": "2026-02-09",
        "calibration_method": "reference_circle",
        "subpixel_precision": 0.05  # 1/20像素
    },
    "dimension": "2D",  # "2D" or "3D"
    "tolerance_standard": "IT8",
    "precision_level": "medium_high",  # 中等高精度
    "features": [
        {
            "id": "F001",
            "type": "diameter",
            "location": {
                "center": [150.5, 200.3],
                "radius": 45.2
            },
            "nominal_value": 10.0,
            "tolerance": 0.11,
            "tolerance_grade": "IT11",
            "measurement_method": "circle_fitting",
            "priority": "high"
        },
        {
            "id": "F002",
            "type": "length",
            "location": {
                "start": [100.0, 100.0],
                "end": [300.0, 100.0]
            },
            "nominal_value": 20.0,
            "tolerance": 0.13,
            "tolerance_grade": "IT11",
            "measurement_method": "edge_to_edge",
            "priority": "high"
        }
    ],
    "inspection_parameters": {
        "image_preprocessing": {
            "denoise": "gaussian",
            "denoise_kernel": 5,
            "contrast_enhancement": true
        },
        "edge_detection": {
            "method": "canny",
            "threshold1": 50,
            "threshold2": 150
        },
        "circle_detection": {
            "method": "hough",
            "dp": 1.0,
            "min_dist": 20,
            "param1": 50,
            "param2": 30,
            "min_radius": 5,
            "max_radius": 100
        }
    }
}
```

### 4.2 模板管理功能

```python
class TemplateManager:
    """检测模板管理器"""

    def __init__(self, template_dir="templates"):
        self.template_dir = template_dir
        self.templates = {}

    def load_template(self, template_name):
        """加载模板"""
        template_path = os.path.join(self.template_dir, f"{template_name}.json")
        with open(template_path, 'r', encoding='utf-8') as f:
            template = json.load(f)

        self.templates[template_name] = template
        return template

    def save_template(self, template_name, template_data):
        """保存模板"""
        os.makedirs(self.template_dir, exist_ok=True)
        template_path = os.path.join(self.template_dir, f"{template_name}.json")

        template_data['modified_date'] = datetime.now().strftime('%Y-%m-%d')

        with open(template_path, 'w', encoding='utf-8') as f:
            json.dump(template_data, f, indent=2, ensure_ascii=False)

        self.templates[template_name] = template_data

    def list_templates(self):
        """列出所有模板"""
        templates = []
        for file_name in os.listdir(self.template_dir):
            if file_name.endswith('.json'):
                template_name = file_name[:-5]
                template = self.load_template(template_name)
                templates.append({
                    'name': template_name,
                    'created_date': template.get('created_date'),
                    'drawing_number': template.get('drawing_info', {}).get('drawing_number'),
                    'feature_count': len(template.get('features', []))
                })

        return templates

    def delete_template(self, template_name):
        """删除模板"""
        template_path = os.path.join(self.template_dir, f"{template_name}.json")
        if os.path.exists(template_path):
            os.remove(template_path)
            if template_name in self.templates:
                del self.templates[template_name]
            return True
        return False
```

---

## 五、应用示例

### 5.1 2D检测完整流程

```python
# 1. 创建标注工具并加载图纸
annotation_tool = DrawingAnnotationTool()
annotation_tool.load_image('part001_drawing.jpg')
annotation_tool.show()

# 2. 用户标注检测部位
#    - 点击"标注直径"按钮，在图纸上标注圆形部位
#    - 点击"标注长度"按钮，在图纸上标注线性部位
#    - 配置每个部位的标称值和公差

# 3. 保存模板
annotation_tool.save_template()

# 4. 使用模板进行检测
engine = InspectionEngine('inspection_template.json')

# 5. 加载检测图像
test_image = cv2.imread('part001_image.jpg')

# 6. 执行检测
results = engine.inspect_part(test_image)

# 7. 输出结果
for result in results:
    print(f"特征类型: {result['feature_type']}")
    print(f"测量值: {result['measured_value']:.3f} mm")
    print(f"标称值: {result['nominal_value']:.3f} mm")
    print(f"公差: ±{result['tolerance']:.3f} mm")
    print(f"是否合格: {'✓' if result['is_within_tolerance'] else '✗'}")
    print("-" * 40)
```

### 5.2 3D检测完整流程

```python
# 1. 创建3D标注工具
annotation_tool_3d = Drawing3DAnnotationTool()
annotation_tool_3d.show()

# 2. 加载3D模型
annotation_tool_3d.load_3d_model('part001.step')

# 3. 用户标注检测部位
#    - 点击"标注面"按钮，选择需要测量的面
#    - 点击"标注边"按钮，选择需要测量的边
#    - 配置每个部位的标称值和公差

# 4. 保存3D模板
annotation_tool_3d.save_template()

# 5. 3D视觉检测
#    - 使用3D相机获取点云数据
#    - 根据模板执行3D测量
#    - 输出检测结果
```

---

## 六、注意事项

### 6.1 2D标定注意事项

1. **图纸质量要求**
   - 图纸分辨率足够高（建议≥300 DPI）
   - 图纸清晰，无明显模糊或失真
   - 尺寸标注清晰可读

2. **标定精度**
   - 使用高精度标定板（建议精度等级IT7或更高）
   - 标定板与检测环境条件一致
   - 定期重新标定（建议每周一次）

3. **标注准确性**
   - 标注时尽量放大图纸以提高精度
   - 使用辅助线和对齐工具
   - 标注后进行验证检查

### 6.2 3D标定注意事项

1. **相机标定**
   - 使用专业标定板（如棋盘格、圆点阵列）
   - 从多个角度采集标定图像（建议15-20张）
   - 确保标定图像覆盖整个视场

2. **手眼标定**
   - 机械臂运动范围覆盖整个检测区域
   - 标定点分布均匀
   - 避免奇点位置

3. **3D模型要求**
   - 模型精度满足检测要求
   - 模型坐标系与实际零件坐标系一致
   - 模型包含完整的几何信息

---

## 七、总结

图纸检测部位预先标定是自动化视觉检测的关键环节，通过以下方式实现：

**2D图纸标定：**
- 基于CAD文件直接解析（推荐，自动化程度高）
- 基于图像手动标注（通用性强）

**3D图纸标定：**
- 基于3D CAD模型解析
- 基于3D视觉传感器标定

**核心步骤：**
1. 图纸/模型导入与解析
2. 检测部位标注
3. 参数配置（标称值、公差）
4. 像素-毫米标定
5. 模板保存与管理
6. 实际检测应用

通过预先标定，可以大幅提高检测效率，减少人工干预，确保检测结果的一致性和准确性。