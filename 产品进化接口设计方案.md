# 产品进化预留接口设计方案（IT8级精度版）

## 一、概述

产品进化预留接口是指在系统设计初期就考虑未来的扩展性、可升级性和可维护性，通过模块化设计、抽象接口、插件机制等方式，为未来的功能扩展和技术升级提供灵活的架构支持。

**精度目标：** IT8级（中等高精度）

**核心技术：** 亚像素级检测算法（1/20像素精度）
**扩展方向：** 可向IT7级精度升级

---

## 二、架构设计原则

### 2.1 核心设计原则

| 原则 | 说明 | 应用场景 |
|------|------|----------|
| **开闭原则** | 对扩展开放，对修改关闭 | 新增检测算法、新的图像处理方法 |
| **依赖倒置** | 依赖抽象而非具体实现 | 图像采集、检测算法、数据存储 |
| **单一职责** | 每个模块只负责一个功能 | 图像预处理、特征提取、结果输出 |
| **接口隔离** | 细粒度接口，避免臃肿 | 检测算法接口、数据接口、UI接口 |
| **里氏替换** | 子类可替换父类 | 不同相机驱动、不同算法实现 |

### 2.2 分层架构

```
┌─────────────────────────────────────────────────────────┐
│                    表现层 (UI Layer)                     │
│  - 主界面  - 配置界面  - 结果显示  - 报表生成            │
├─────────────────────────────────────────────────────────┤
│                  应用层 (Application Layer)              │
│  - 检测流程编排  - 任务调度  - 异常处理                  │
├─────────────────────────────────────────────────────────┤
│                  领域层 (Domain Layer)                   │
│  - 图像处理领域  - 检测算法领域  - 数据管理领域          │
├─────────────────────────────────────────────────────────┤
│                  基础设施层 (Infrastructure Layer)        │
│  - 图像采集  - 数据存储  - 硬件接口  - 第三方集成        │
└─────────────────────────────────────────────────────────┘
```

---

## 三、核心接口设计

### 3.1 图像采集接口

```python
from abc import ABC, abstractmethod
from typing import Optional, Tuple
import numpy as np

class IImageAcquisition(ABC):
    """图像采集接口 - 支持多种相机类型"""

    @abstractmethod
    def connect(self, device_id: str) -> bool:
        """连接相机设备"""
        pass

    @abstractmethod
    def disconnect(self) -> bool:
        """断开相机连接"""
        pass

    @abstractmethod
    def is_connected(self) -> bool:
        """检查相机连接状态"""
        pass

    @abstractmethod
    def capture_image(self) -> Optional[np.ndarray]:
        """采集单帧图像"""
        pass

    @abstractmethod
    def start_continuous_capture(self, callback) -> bool:
        """开始连续采集"""
        pass

    @abstractmethod
    def stop_continuous_capture(self) -> bool:
        """停止连续采集"""
        pass

    @abstractmethod
    def set_exposure(self, exposure: float) -> bool:
        """设置曝光时间"""
        pass

    @abstractmethod
    def set_gain(self, gain: float) -> bool:
        """设置增益"""
        pass

    @abstractmethod
    def get_camera_info(self) -> dict:
        """获取相机信息"""
        pass


# 实现示例：USB相机
class USBCameraDriver(IImageAcquisition):
    """USB相机驱动实现"""

    def __init__(self):
        self.camera = None
        self.is_capturing = False

    def connect(self, device_id: str) -> bool:
        import cv2
        try:
            self.camera = cv2.VideoCapture(int(device_id))
            return self.camera.isOpened()
        except Exception as e:
            print(f"连接USB相机失败: {e}")
            return False

    def disconnect(self) -> bool:
        if self.camera:
            self.camera.release()
            self.camera = None
        return True

    def is_connected(self) -> bool:
        return self.camera is not None and self.camera.isOpened()

    def capture_image(self) -> Optional[np.ndarray]:
        if not self.is_connected():
            return None

        ret, frame = self.camera.read()
        return frame if ret else None

    def start_continuous_capture(self, callback) -> bool:
        self.is_capturing = True
        # 启动线程进行连续采集
        import threading
        self.capture_thread = threading.Thread(
            target=self._capture_loop, args=(callback,)
        )
        self.capture_thread.start()
        return True

    def _capture_loop(self, callback):
        while self.is_capturing:
            image = self.capture_image()
            if image is not None:
                callback(image)

    def stop_continuous_capture(self) -> bool:
        self.is_capturing = False
        return True

    def set_exposure(self, exposure: float) -> bool:
        # USB相机可能不支持精确曝光控制
        return True

    def set_gain(self, gain: float) -> bool:
        # USB相机可能不支持精确增益控制
        return True

    def get_camera_info(self) -> dict:
        return {
            'type': 'USB',
            'device_id': str(id(self.camera)),
            'resolution': self.get_resolution()
        }

    def get_resolution(self) -> Tuple[int, int]:
        if self.camera:
            width = int(self.camera.get(cv2.CAP_PROP_FRAME_WIDTH))
            height = int(self.camera.get(cv2.CAP_PROP_FRAME_HEIGHT))
            return (width, height)
        return (0, 0)


# 实现示例：GigE工业相机
class GigECameraDriver(IImageAcquisition):
    """GigE工业相机驱动实现"""

    def __init__(self):
        self.camera = None
        self.is_capturing = False

    def connect(self, device_id: str) -> bool:
        # 使用GigE相机SDK连接
        # 这里是伪代码，实际需要使用相机厂商SDK
        try:
            # import pypylon  # Basler相机SDK
            # self.camera = pypylon.InstantCamera(pypylon.TlFactory.GetInstance().CreateDevice(device_id))
            # self.camera.Open()
            return True
        except Exception as e:
            print(f"连接GigE相机失败: {e}")
            return False

    def disconnect(self) -> bool:
        if self.camera:
            # self.camera.Close()
            self.camera = None
        return True

    def is_connected(self) -> bool:
        return self.camera is not None

    def capture_image(self) -> Optional[np.ndarray]:
        if not self.is_connected():
            return None

        # self.camera.StartGrabbing()
        # grabResult = self.camera.RetrieveResult(5000)
        # image = grabResult.Array
        # return image
        return None

    def start_continuous_capture(self, callback) -> bool:
        self.is_capturing = True
        # 实现连续采集逻辑
        return True

    def stop_continuous_capture(self) -> bool:
        self.is_capturing = False
        return True

    def set_exposure(self, exposure: float) -> bool:
        if self.camera:
            # self.camera.ExposureTime.SetValue(exposure)
            return True
        return False

    def set_gain(self, gain: float) -> bool:
        if self.camera:
            # self.camera.Gain.SetValue(gain)
            return True
        return False

    def get_camera_info(self) -> dict:
        return {
            'type': 'GigE',
            'device_id': str(id(self.camera)),
            'model': 'Unknown',
            'serial_number': 'Unknown'
        }


# 相机工厂
class CameraFactory:
    """相机工厂 - 根据类型创建相机实例"""

    _camera_types = {
        'usb': USBCameraDriver,
        'gige': GigECameraDriver,
        # 未来可扩展其他相机类型
        # 'halcon': HalconCameraDriver,
        # 'basler': BaslerCameraDriver,
        # 'hikvision': HikvisionCameraDriver,
    }

    @classmethod
    def create_camera(cls, camera_type: str) -> IImageAcquisition:
        """创建相机实例"""
        camera_class = cls._camera_types.get(camera_type.lower())
        if camera_class:
            return camera_class()
        else:
            raise ValueError(f"不支持的相机类型: {camera_type}")

    @classmethod
    def register_camera_type(cls, camera_type: str, camera_class):
        """注册新的相机类型（扩展点）"""
        cls._camera_types[camera_type.lower()] = camera_class

    @classmethod
    def get_supported_types(cls) -> list:
        """获取支持的相机类型列表"""
        return list(cls._camera_types.keys())
```

---

### 3.2 图像预处理接口

```python
class IImagePreprocessor(ABC):
    """图像预处理接口 - 支持多种预处理算法"""

    @abstractmethod
    def process(self, image: np.ndarray) -> np.ndarray:
        """处理图像"""
        pass

    @abstractmethod
    def get_parameters(self) -> dict:
        """获取当前参数"""
        pass

    @abstractmethod
    def set_parameters(self, parameters: dict) -> bool:
        """设置参数"""
        pass

    @abstractmethod
    def get_name(self) -> str:
        """获取处理器名称"""
        pass


# 基础预处理器
class BasePreprocessor(IImagePreprocessor):
    """预处理器基类"""

    def __init__(self):
        self.parameters = {}

    def get_parameters(self) -> dict:
        return self.parameters.copy()

    def set_parameters(self, parameters: dict) -> bool:
        self.parameters.update(parameters)
        return True


# 实现示例：高斯滤波
class GaussianFilter(BasePreprocessor):
    """高斯滤波器"""

    def __init__(self, kernel_size: int = 5, sigma: float = 1.0):
        super().__init__()
        self.parameters = {
            'kernel_size': kernel_size,
            'sigma': sigma
        }

    def process(self, image: np.ndarray) -> np.ndarray:
        import cv2
        return cv2.GaussianBlur(
            image,
            (self.parameters['kernel_size'], self.parameters['kernel_size']),
            self.parameters['sigma']
        )

    def get_name(self) -> str:
        return "Gaussian Filter"


# 实现示例：中值滤波
class MedianFilter(BasePreprocessor):
    """中值滤波器"""

    def __init__(self, kernel_size: int = 5):
        super().__init__()
        self.parameters = {'kernel_size': kernel_size}

    def process(self, image: np.ndarray) -> np.ndarray:
        import cv2
        return cv2.medianBlur(image, self.parameters['kernel_size'])

    def get_name(self) -> str:
        return "Median Filter"


# 实现示例：直方图均衡化
class HistogramEqualization(BasePreprocessor):
    """直方图均衡化"""

    def __init__(self):
        super().__init__()

    def process(self, image: np.ndarray) -> np.ndarray:
        import cv2
        if len(image.shape) == 2:  # 灰度图
            return cv2.equalizeHist(image)
        else:  # 彩色图
            ycrcb = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)
            ycrcb[:, :, 0] = cv2.equalizeHist(ycrcb[:, :, 0])
            return cv2.cvtColor(ycrcb, cv2.COLOR_YCrCb2BGR)

    def get_name(self) -> str:
        return "Histogram Equalization"


# 实现示例：CLAHE（自适应直方图均衡化，适合IT8级精度）
class CLAHEPreprocessor(BasePreprocessor):
    """CLAHE自适应直方图均衡化 - 提高对比度，增强边缘"""

    def __init__(self, clip_limit=2.0, tile_grid_size=(8, 8)):
        super().__init__()
        self.parameters = {
            'clip_limit': clip_limit,
            'tile_grid_size': tile_grid_size
        }
        self.clahe = None

    def process(self, image: np.ndarray) -> np.ndarray:
        import cv2
        if self.clahe is None:
            self.clahe = cv2.createCLAHE(
                clipLimit=self.parameters['clip_limit'],
                tileGridSize=self.parameters['tile_grid_size']
            )

        if len(image.shape) == 2:  # 灰度图
            return self.clahe.apply(image)
        else:  # 彩色图
            ycrcb = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)
            ycrcb[:, :, 0] = self.clahe.apply(ycrcb[:, :, 0])
            return cv2.cvtColor(ycrcb, cv2.COLOR_YCrCb2BGR)

    def get_name(self) -> str:
        return "CLAHE"


# 预处理管道
class PreprocessingPipeline:
    """预处理管道 - 支持链式处理"""

    def __init__(self):
        self.processors = []

    def add_processor(self, processor: IImagePreprocessor):
        """添加预处理器"""
        self.processors.append(processor)
        return self

    def remove_processor(self, index: int):
        """移除预处理器"""
        if 0 <= index < len(self.processors):
            self.processors.pop(index)

    def process(self, image: np.ndarray) -> np.ndarray:
        """执行管道处理"""
        result = image
        for processor in self.processors:
            result = processor.process(result)
        return result

    def get_processor_count(self) -> int:
        """获取处理器数量"""
        return len(self.processors)

    def clear(self):
        """清空管道"""
        self.processors = []
```

---

### 3.3 检测算法接口

```python
from typing import List, Dict, Any
from dataclasses import dataclass
from enum import Enum

class FeatureType(Enum):
    """特征类型枚举"""
    DIAMETER = "diameter"
    LENGTH = "length"
    WIDTH = "width"
    HEIGHT = "height"
    ANGLE = "angle"
    POSITION = "position"
    AREA = "area"
    PERIMETER = "perimeter"
    # 未来可扩展
    # CIRCULARITY = "circularity"
    # ROUGHNESS = "roughness"


@dataclass
class InspectionResult:
    """检测结果数据类"""
    feature_type: FeatureType
    feature_id: str
    measured_value: float
    nominal_value: float
    tolerance: float
    is_within_tolerance: bool
    unit: str = "mm"
    confidence: float = 1.0
    metadata: Dict[str, Any] = None
    subpixel_precision: float = 0.05  # IT8级：1/20像素
    tolerance_grade: str = "IT8"  # 公差等级

    def to_dict(self) -> dict:
        """转换为字典"""
        return {
            'feature_type': self.feature_type.value,
            'feature_id': self.feature_id,
            'measured_value': self.measured_value,
            'nominal_value': self.nominal_value,
            'tolerance': self.tolerance,
            'is_within_tolerance': self.is_within_tolerance,
            'unit': self.unit,
            'confidence': self.confidence,
            'metadata': self.metadata or {},
            'subpixel_precision': self.subpixel_precision,
            'tolerance_grade': self.tolerance_grade
        }


class IDetectionAlgorithm(ABC):
    """检测算法接口 - 核心可扩展接口"""

    @abstractmethod
    def detect(self, image: np.ndarray, feature_info: dict) -> InspectionResult:
        """执行检测"""
        pass

    @abstractmethod
    def validate_input(self, feature_info: dict) -> bool:
        """验证输入参数"""
        pass

    @abstractmethod
    def get_algorithm_name(self) -> str:
        """获取算法名称"""
        pass

    @abstractmethod
    def get_supported_features(self) -> List[FeatureType]:
        """获取支持的特征类型"""
        pass

    @abstractmethod
    def set_parameters(self, parameters: dict) -> bool:
        """设置算法参数"""
        pass

    @abstractmethod
    def get_parameters(self) -> dict:
        """获取算法参数"""
        pass


# 基础检测算法
class BaseDetectionAlgorithm(IDetectionAlgorithm):
    """检测算法基类"""

    def __init__(self):
        self.parameters = {}

    def validate_input(self, feature_info: dict) -> bool:
        """基础验证"""
        required_fields = ['id', 'type', 'nominal_value', 'tolerance']
        return all(field in feature_info for field in required_fields)

    def set_parameters(self, parameters: dict) -> bool:
        self.parameters.update(parameters)
        return True

    def get_parameters(self) -> dict:
        return self.parameters.copy()


# 实现示例：圆形检测算法
class CircleDetectionAlgorithm(BaseDetectionAlgorithm):
    """圆形检测算法（IT8级精度）"""

    def __init__(self):
        super().__init__()
        self.parameters = {
            'method': 'hough_subpixel',  # hough_subpixel, contour, fitting
            'dp': 1.0,
            'min_dist': 20,
            'param1': 50,
            'param2': 30,
            'min_radius': 5,
            'max_radius': 100,
            'subpixel_iterations': 10,
            'subpixel_precision': 0.05  # 1/20像素
        }

    def get_algorithm_name(self) -> str:
        return "Circle Detection (IT8)"

    def get_supported_features(self) -> List[FeatureType]:
        return [FeatureType.DIAMETER, FeatureType.POSITION]

    def detect(self, image: np.ndarray, feature_info: dict) -> InspectionResult:
        import cv2
        import numpy as np

        if not self.validate_input(feature_info):
            raise ValueError("无效的特征信息")

        # 提取ROI
        roi = self._extract_roi(image, feature_info)

        # 边缘检测
        edges = cv2.Canny(roi, 50, 150)

        # 霍夫圆检测
        circles = cv2.HoughCircles(
            edges, cv2.HOUGH_GRADIENT,
            dp=self.parameters['dp'],
            minDist=self.parameters['min_dist'],
            param1=self.parameters['param1'],
            param2=self.parameters['param2'],
            minRadius=self.parameters['min_radius'],
            maxRadius=self.parameters['max_radius']
        )

        if circles is not None:
            circle = circles[0][0]

            # 亚像素精细化
            refined_circle = self._subpixel_refine_circle(roi, circle)

            pixel_diameter = refined_circle[2] * 2

            # 像素转毫米（需要预先标定）
            pixel_to_mm = self.parameters.get('pixel_to_mm', 0.01)
            mm_diameter = pixel_diameter * pixel_to_mm

            # 计算结果
            nominal_value = feature_info['nominal_value']
            tolerance = feature_info['tolerance']
            is_within_tolerance = abs(mm_diameter - nominal_value) <= tolerance

            return InspectionResult(
                feature_type=FeatureType.DIAMETER,
                feature_id=feature_info['id'],
                measured_value=mm_diameter,
                nominal_value=nominal_value,
                tolerance=tolerance,
                is_within_tolerance=is_within_tolerance,
                tolerance_grade="IT8",
                subpixel_precision=self.parameters['subpixel_precision'],
                metadata={
                    'center': (refined_circle[0], refined_circle[1]),
                    'radius': refined_circle[2],
                    'pixel_diameter': pixel_diameter,
                    'refinement_iterations': self.parameters['subpixel_iterations']
                }
            )
        else:
            # 未检测到圆形，返回默认结果
            return InspectionResult(
                feature_type=FeatureType.DIAMETER,
                feature_id=feature_info['id'],
                measured_value=0.0,
                nominal_value=feature_info['nominal_value'],
                tolerance=feature_info['tolerance'],
                is_within_tolerance=False,
                tolerance_grade="IT8",
                confidence=0.0,
                metadata={'error': 'No circle detected'}
            )

    def _subpixel_refine_circle(self, image, initial_circle):
        """亚像素圆精细化"""
        import cv2

        x, y, r = initial_circle

        # 在圆周上提取边缘点
        edge_points = []
        num_samples = 36
        for i in range(num_samples):
            angle = 2 * np.pi * i / num_samples
            px = int(x + r * np.cos(angle))
            py = int(y + r * np.sin(angle))

            if 0 <= px < image.shape[1] and 0 <= py < image.shape[0]:
                edge_points.append([px, py])

        if len(edge_points) < 5:
            return initial_circle

        edge_points = np.array(edge_points)

        # 使用cornerSubPix进行亚像素精细化
        edge_points_reshaped = edge_points.reshape(-1, 1, 2)
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        refined_points = cv2.cornerSubPix(image, edge_points_reshaped, (5, 5), (-1, -1), criteria)

        # 使用精细化点重新拟合圆
        refined_x, refined_y, refined_r = self._fit_circle(refined_points.reshape(-1, 2))

        return np.array([refined_x, refined_y, refined_r])

    def _fit_circle(self, points):
        """最小二乘圆拟合"""
        if len(points) < 3:
            return 0, 0, 0

        x = points[:, 0]
        y = points[:, 1]

        A = np.column_stack([2*x, 2*y, np.ones_like(x)])
        b = x**2 + y**2

        coeffs, _, _, _ = np.linalg.lstsq(A, b, rcond=None)

        a, b, c = coeffs
        center_x = a
        center_y = b
        radius = np.sqrt(a**2 + b**2 + c)

        return center_x, center_y, radius

    def _extract_roi(self, image: np.ndarray, feature_info: dict) -> np.ndarray:
        """提取感兴趣区域"""
        if 'location' in feature_info:
            loc = feature_info['location']
            center = loc.get('center', (0, 0))
            radius = loc.get('radius', 100)

            x1 = max(0, int(center[0] - radius * 1.5))
            y1 = max(0, int(center[1] - radius * 1.5))
            x2 = min(image.shape[1], int(center[0] + radius * 1.5))
            y2 = min(image.shape[0], int(center[1] + radius * 1.5))

            return image[y1:y2, x1:x2]
        return image


# 实现示例：线性检测算法
class LinearDetectionAlgorithm(BaseDetectionAlgorithm):
    """线性检测算法（长度/宽度，IT8级精度）"""

    def __init__(self):
        super().__init__()
        self.parameters = {
            'method': 'edge_to_edge_subpixel',  # edge_to_edge_subpixel, bounding_box
            'pixel_to_mm': 0.01,
            'subpixel_precision': 0.05  # 1/20像素
        }

    def get_algorithm_name(self) -> str:
        return "Linear Detection (IT8)"

    def get_supported_features(self) -> List[FeatureType]:
        return [FeatureType.LENGTH, FeatureType.WIDTH]

    def detect(self, image: np.ndarray, feature_info: dict) -> InspectionResult:
        import cv2
        import numpy as np

        if not self.validate_input(feature_info):
            raise ValueError("无效的特征信息")

        # 提取ROI
        roi = self._extract_roi(image, feature_info)

        # 边缘检测
        edges = cv2.Canny(roi, 50, 150)

        # 寻找轮廓
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)

        if contours:
            # 获取最小外接矩形
            rect = cv2.minAreaRect(max(contours, key=cv2.contourArea))
            box = cv2.boxPoints(rect)
            box = np.int0(box)

            # 对角点进行亚像素精细化
            refined_box = self._subpixel_refine_corners(roi, box)

            # 计算长宽
            width = np.linalg.norm(refined_box[0] - refined_box[1])
            height = np.linalg.norm(refined_box[1] - refined_box[2])

            feature_type = FeatureType(feature_info['type'])
            pixel_length = max(width, height) if feature_type == FeatureType.LENGTH else min(width, height)

            # 像素转毫米
            mm_length = pixel_length * self.parameters['pixel_to_mm']

            # 计算结果
            nominal_value = feature_info['nominal_value']
            tolerance = feature_info['tolerance']
            is_within_tolerance = abs(mm_length - nominal_value) <= tolerance

            return InspectionResult(
                feature_type=feature_type,
                feature_id=feature_info['id'],
                measured_value=mm_length,
                nominal_value=nominal_value,
                tolerance=tolerance,
                is_within_tolerance=is_within_tolerance,
                tolerance_grade="IT8",
                subpixel_precision=self.parameters['subpixel_precision'],
                metadata={
                    'width': width * self.parameters['pixel_to_mm'],
                    'height': height * self.parameters['pixel_to_mm'],
                    'angle': rect[2]
                }
            )
        else:
            return InspectionResult(
                feature_type=FeatureType(feature_info['type']),
                feature_id=feature_info['id'],
                measured_value=0.0,
                nominal_value=feature_info['nominal_value'],
                tolerance=feature_info['tolerance'],
                is_within_tolerance=False,
                tolerance_grade="IT8",
                confidence=0.0,
                metadata={'error': 'No contour detected'}
            )

    def _subpixel_refine_corners(self, image, corners):
        """亚像素角点精细化"""
        import cv2

        refined_corners = []
        for point in corners:
            # 提取角点附近的ROI
            x, y = int(point[0]), int(point[1])
            roi_size = 10
            x1 = max(0, x - roi_size)
            y1 = max(0, y - roi_size)
            x2 = min(image.shape[1], x + roi_size + 1)
            y2 = min(image.shape[0], y + roi_size + 1)

            roi = image[y1:y2, x1:x2]

            if roi.size > 0:
                # 亚像素角点检测
                corners_detected = cv2.goodFeaturesToTrack(
                    roi, maxCorners=1, qualityLevel=0.01, minDistance=5
                )

                if corners_detected is not None:
                    # 亚像素精细化
                    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
                    refined = cv2.cornerSubPix(roi, corners_detected, (5, 5), (-1, -1), criteria)

                    # 转换回原始坐标系
                    refined_x = refined[0][0][0] + (x - roi_size)
                    refined_y = refined[0][0][1] + (y - roi_size)
                    refined_corners.append([refined_x, refined_y])
                else:
                    refined_corners.append([x, y])
            else:
                refined_corners.append([x, y])

        return np.array(refined_corners)

    def _extract_roi(self, image: np.ndarray, feature_info: dict) -> np.ndarray:
        """提取感兴趣区域"""
        if 'location' in feature_info:
            loc = feature_info['location']
            start = loc.get('start', (0, 0))
            end = loc.get('end', (image.shape[1], image.shape[0]))

            x1 = min(start[0], end[0]) - 50
            y1 = min(start[1], end[1]) - 50
            x2 = max(start[0], end[0]) + 50
            y2 = max(start[1], end[1]) + 50

            x1 = max(0, int(x1))
            y1 = max(0, int(y1))
            x2 = min(image.shape[1], int(x2))
            y2 = min(image.shape[0], int(y2))

            return image[y1:y2, x1:x2]
        return image


# 算法工厂
class DetectionAlgorithmFactory:
    """检测算法工厂 - 支持算法注册和创建"""

    _algorithms = {
        'circle': CircleDetectionAlgorithm,
        'linear': LinearDetectionAlgorithm,
        # 未来可扩展其他算法
        # 'ellipse': EllipseDetectionAlgorithm,
        # 'polygon': PolygonDetectionAlgorithm,
        # 'template_matching': TemplateMatchingAlgorithm,
        # 'deep_learning': DeepLearningDetectionAlgorithm,
    }

    @classmethod
    def create_algorithm(cls, algorithm_type: str) -> IDetectionAlgorithm:
        """创建算法实例"""
        algorithm_class = cls._algorithms.get(algorithm_type.lower())
        if algorithm_class:
            return algorithm_class()
        else:
            raise ValueError(f"不支持的算法类型: {algorithm_type}")

    @classmethod
    def register_algorithm(cls, algorithm_type: str, algorithm_class):
        """注册新的算法类型（扩展点）"""
        cls._algorithms[algorithm_type.lower()] = algorithm_class

    @classmethod
    def get_supported_algorithms(cls) -> list:
        """获取支持的算法列表"""
        return list(cls._algorithms.keys())

    @classmethod
    def get_algorithm(cls, algorithm_type: str, feature_type: FeatureType) -> IDetectionAlgorithm:
        """根据特征类型获取合适的算法"""
        # 这里可以根据特征类型自动选择算法
        if feature_type == FeatureType.DIAMETER:
            return cls.create_algorithm('circle')
        elif feature_type in [FeatureType.LENGTH, FeatureType.WIDTH]:
            return cls.create_algorithm('linear')
        else:
            raise ValueError(f"不支持的特征类型: {feature_type}")
```

---

### 3.4 数据存储接口

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from datetime import datetime
import json
import os

class IDataStorage(ABC):
    """数据存储接口 - 支持多种存储方式"""

    @abstractmethod
    def save_inspection_result(self, result: InspectionResult) -> bool:
        """保存检测结果"""
        pass

    @abstractmethod
    def save_inspection_batch(self, results: List[InspectionResult]) -> bool:
        """批量保存检测结果"""
        pass

    @abstractmethod
    def get_inspection_results(self, start_time: datetime,
                                end_time: datetime) -> List[InspectionResult]:
        """获取检测结果"""
        pass

    @abstractmethod
    def save_image(self, image: np.ndarray, image_id: str) -> bool:
        """保存图像"""
        pass

    @abstractmethod
    def get_image(self, image_id: str) -> Optional[np.ndarray]:
        """获取图像"""
        pass

    @abstractmethod
    def save_template(self, template: dict, template_name: str) -> bool:
        """保存检测模板"""
        pass

    @abstractmethod
    def get_template(self, template_name: str) -> Optional[dict]:
        """获取检测模板"""
        pass

    @abstractmethod
    def list_templates(self) -> List[str]:
        """列出所有模板"""
        pass


# 实现示例：文件系统存储
class FileSystemStorage(IDataStorage):
    """文件系统存储实现"""

    def __init__(self, base_dir: str = "./data"):
        self.base_dir = base_dir
        self.results_dir = os.path.join(base_dir, "results")
        self.images_dir = os.path.join(base_dir, "images")
        self.templates_dir = os.path.join(base_dir, "templates")

        # 创建目录
        os.makedirs(self.results_dir, exist_ok=True)
        os.makedirs(self.images_dir, exist_ok=True)
        os.makedirs(self.templates_dir, exist_ok=True)

    def save_inspection_result(self, result: InspectionResult) -> bool:
        try:
            filename = f"result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            filepath = os.path.join(self.results_dir, filename)

            data = result.to_dict()
            data['timestamp'] = datetime.now().isoformat()

            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)

            return True
        except Exception as e:
            print(f"保存检测结果失败: {e}")
            return False

    def save_inspection_batch(self, results: List[InspectionResult]) -> bool:
        try:
            filename = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            filepath = os.path.join(self.results_dir, filename)

            data = {
                'timestamp': datetime.now().isoformat(),
                'results': [result.to_dict() for result in results]
            }

            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)

            return True
        except Exception as e:
            print(f"批量保存检测结果失败: {e}")
            return False

    def get_inspection_results(self, start_time: datetime,
                                end_time: datetime) -> List[InspectionResult]:
        results = []

        for filename in os.listdir(self.results_dir):
            if filename.endswith('.json'):
                filepath = os.path.join(self.results_dir, filename)

                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)

                # 解析时间戳
                timestamp_str = data.get('timestamp', '')
                if timestamp_str:
                    try:
                        timestamp = datetime.fromisoformat(timestamp_str)
                        if start_time <= timestamp <= end_time:
                            results.append(data)
                    except ValueError:
                        continue

        return results

    def save_image(self, image: np.ndarray, image_id: str) -> bool:
        try:
            import cv2
            filepath = os.path.join(self.images_dir, f"{image_id}.png")
            cv2.imwrite(filepath, image)
            return True
        except Exception as e:
            print(f"保存图像失败: {e}")
            return False

    def get_image(self, image_id: str) -> Optional[np.ndarray]:
        try:
            import cv2
            filepath = os.path.join(self.images_dir, f"{image_id}.png")
            image = cv2.imread(filepath)
            return image if image is not None else None
        except Exception as e:
            print(f"获取图像失败: {e}")
            return None

    def save_template(self, template: dict, template_name: str) -> bool:
        try:
            filepath = os.path.join(self.templates_dir, f"{template_name}.json")
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(template, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"保存模板失败: {e}")
            return False

    def get_template(self, template_name: str) -> Optional[dict]:
        try:
            filepath = os.path.join(self.templates_dir, f"{template_name}.json")
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"获取模板失败: {e}")
            return None

    def list_templates(self) -> List[str]:
        templates = []
        for filename in os.listdir(self.templates_dir):
            if filename.endswith('.json'):
                templates.append(filename[:-5])  # 去掉.json后缀
        return templates


# 实现示例：SQLite数据库存储
class SQLiteStorage(IDataStorage):
    """SQLite数据库存储实现"""

    def __init__(self, db_path: str = "./data/inspection.db"):
        import sqlite3
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)
        self._create_tables()

    def _create_tables(self):
        """创建数据库表"""
        cursor = self.conn.cursor()

        # 检测结果表
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS inspection_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                feature_id TEXT NOT NULL,
                feature_type TEXT NOT NULL,
                measured_value REAL NOT NULL,
                nominal_value REAL NOT NULL,
                tolerance REAL NOT NULL,
                is_within_tolerance BOOLEAN NOT NULL,
                unit TEXT DEFAULT 'mm',
                confidence REAL DEFAULT 1.0,
                metadata TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        # 模板表
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS templates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                content TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        self.conn.commit()

    def save_inspection_result(self, result: InspectionResult) -> bool:
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                INSERT INTO inspection_results
                (feature_id, feature_type, measured_value, nominal_value,
                 tolerance, is_within_tolerance, unit, confidence, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                result.feature_id,
                result.feature_type.value,
                result.measured_value,
                result.nominal_value,
                result.tolerance,
                result.is_within_tolerance,
                result.unit,
                result.confidence,
                json.dumps(result.metadata) if result.metadata else None
            ))
            self.conn.commit()
            return True
        except Exception as e:
            print(f"保存检测结果失败: {e}")
            return False

    def save_inspection_batch(self, results: List[InspectionResult]) -> bool:
        try:
            cursor = self.conn.cursor()
            for result in results:
                cursor.execute('''
                    INSERT INTO inspection_results
                    (feature_id, feature_type, measured_value, nominal_value,
                     tolerance, is_within_tolerance, unit, confidence, metadata)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    result.feature_id,
                    result.feature_type.value,
                    result.measured_value,
                    result.nominal_value,
                    result.tolerance,
                    result.is_within_tolerance,
                    result.unit,
                    result.confidence,
                    json.dumps(result.metadata) if result.metadata else None
                ))
            self.conn.commit()
            return True
        except Exception as e:
            print(f"批量保存检测结果失败: {e}")
            return False

    def get_inspection_results(self, start_time: datetime,
                                end_time: datetime) -> List[InspectionResult]:
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT feature_id, feature_type, measured_value, nominal_value,
                   tolerance, is_within_tolerance, unit, confidence, metadata
            FROM inspection_results
            WHERE timestamp BETWEEN ? AND ?
            ORDER BY timestamp DESC
        ''', (start_time.isoformat(), end_time.isoformat()))

        results = []
        for row in cursor.fetchall():
            results.append(InspectionResult(
                feature_type=FeatureType(row[1]),
                feature_id=row[0],
                measured_value=row[2],
                nominal_value=row[3],
                tolerance=row[4],
                is_within_tolerance=row[5],
                unit=row[6],
                confidence=row[7],
                metadata=json.loads(row[8]) if row[8] else None
            ))

        return results

    def save_image(self, image: np.ndarray, image_id: str) -> bool:
        # SQLite不适合存储大文件，这里使用文件系统
        return FileSystemStorage().save_image(image, image_id)

    def get_image(self, image_id: str) -> Optional[np.ndarray]:
        return FileSystemStorage().get_image(image_id)

    def save_template(self, template: dict, template_name: str) -> bool:
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO templates (name, content, updated_at)
                VALUES (?, ?, CURRENT_TIMESTAMP)
            ''', (template_name, json.dumps(template)))
            self.conn.commit()
            return True
        except Exception as e:
            print(f"保存模板失败: {e}")
            return False

    def get_template(self, template_name: str) -> Optional[dict]:
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT content FROM templates WHERE name = ?', (template_name,))
            row = cursor.fetchone()
            if row:
                return json.loads(row[0])
            return None
        except Exception as e:
            print(f"获取模板失败: {e}")
            return None

    def list_templates(self) -> List[str]:
        cursor = self.conn.cursor()
        cursor.execute('SELECT name FROM templates')
        return [row[0] for row in cursor.fetchall()]

    def close(self):
        """关闭数据库连接"""
        self.conn.close()


# 存储工厂
class StorageFactory:
    """存储工厂 - 支持多种存储方式"""

    _storage_types = {
        'filesystem': FileSystemStorage,
        'sqlite': SQLiteStorage,
        # 未来可扩展其他存储方式
        # 'mysql': MySQLStorage,
        # 'postgresql': PostgreSQLStorage,
        # 'mongodb': MongoDBStorage,
    }

    @classmethod
    def create_storage(cls, storage_type: str, **kwargs) -> IDataStorage:
        """创建存储实例"""
        storage_class = cls._storage_types.get(storage_type.lower())
        if storage_class:
            return storage_class(**kwargs)
        else:
            raise ValueError(f"不支持的存储类型: {storage_type}")

    @classmethod
    def register_storage_type(cls, storage_type: str, storage_class):
        """注册新的存储类型（扩展点）"""
        cls._storage_types[storage_type.lower()] = storage_class

    @classmethod
    def get_supported_types(cls) -> list:
        """获取支持的存储类型列表"""
        return list(cls._storage_types.keys())
```

---

### 3.5 插件系统接口

```python
import importlib
import inspect
from typing import Type, Dict, List
import os

class IPlugin(ABC):
    """插件接口 - 所有插件必须实现此接口"""

    @abstractmethod
    def get_name(self) -> str:
        """获取插件名称"""
        pass

    @abstractmethod
    def get_version(self) -> str:
        """获取插件版本"""
        pass

    @abstractmethod
    def get_description(self) -> str:
        """获取插件描述"""
        pass

    @abstractmethod
    def initialize(self, config: dict) -> bool:
        """初始化插件"""
        pass

    @abstractmethod
    def shutdown(self) -> bool:
        """关闭插件"""
        pass


class PluginManager:
    """插件管理器 - 负责插件的加载、卸载和管理"""

    def __init__(self):
        self.plugins: Dict[str, IPlugin] = {}
        self.plugin_dirs = []

    def add_plugin_dir(self, plugin_dir: str):
        """添加插件目录"""
        if os.path.isdir(plugin_dir) and plugin_dir not in self.plugin_dirs:
            self.plugin_dirs.append(plugin_dir)

    def load_plugin(self, plugin_path: str) -> bool:
        """加载插件"""
        try:
            # 动态导入插件模块
            spec = importlib.util.spec_from_file_location("plugin", plugin_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            # 查找实现IPlugin接口的类
            for name, obj in inspect.getmembers(module):
                if inspect.isclass(obj) and issubclass(obj, IPlugin) and obj != IPlugin:
                    plugin = obj()
                    plugin.initialize({})
                    self.plugins[plugin.get_name()] = plugin
                    print(f"插件加载成功: {plugin.get_name()} v{plugin.get_version()}")
                    return True

            return False
        except Exception as e:
            print(f"插件加载失败: {e}")
            return False

    def load_plugins_from_dir(self, plugin_dir: str) -> int:
        """从目录加载所有插件"""
        count = 0
        if os.path.isdir(plugin_dir):
            for filename in os.listdir(plugin_dir):
                if filename.endswith('.py') and not filename.startswith('_'):
                    plugin_path = os.path.join(plugin_dir, filename)
                    if self.load_plugin(plugin_path):
                        count += 1
        return count

    def unload_plugin(self, plugin_name: str) -> bool:
        """卸载插件"""
        if plugin_name in self.plugins:
            self.plugins[plugin_name].shutdown()
            del self.plugins[plugin_name]
            return True
        return False

    def get_plugin(self, plugin_name: str) -> Optional[IPlugin]:
        """获取插件"""
        return self.plugins.get(plugin_name)

    def list_plugins(self) -> List[Dict]:
        """列出所有插件"""
        return [
            {
                'name': plugin.get_name(),
                'version': plugin.get_version(),
                'description': plugin.get_description()
            }
            for plugin in self.plugins.values()
        ]


# 插件示例：自定义检测算法插件
class CustomDetectionAlgorithmPlugin(IPlugin):
    """自定义检测算法插件示例"""

    def get_name(self) -> str:
        return "Custom Detection Algorithm"

    def get_version(self) -> str:
        return "1.0.0"

    def get_description(self) -> str:
        return "自定义检测算法插件，支持特殊形状检测"

    def initialize(self, config: dict) -> bool:
        # 注册自定义算法到算法工厂
        DetectionAlgorithmFactory.register_algorithm(
            'custom',
            CustomDetectionAlgorithm
        )
        return True

    def shutdown(self) -> bool:
        # 清理资源
        return True


class CustomDetectionAlgorithm(BaseDetectionAlgorithm):
    """自定义检测算法实现"""

    def get_algorithm_name(self) -> str:
        return "Custom Detection"

    def get_supported_features(self) -> List[FeatureType]:
        return [FeatureType.DIAMETER, FeatureType.LENGTH]

    def detect(self, image: np.ndarray, feature_info: dict) -> InspectionResult:
        # 实现自定义检测逻辑
        # ...
        return InspectionResult(
            feature_type=FeatureType(feature_info['type']),
            feature_id=feature_info['id'],
            measured_value=0.0,
            nominal_value=feature_info['nominal_value'],
            tolerance=feature_info['tolerance'],
            is_within_tolerance=False
        )
```

---

### 3.6 配置管理接口

```python
from abc import ABC, abstractmethod
from typing import Any, Dict

class IConfigurationProvider(ABC):
    """配置提供者接口"""

    @abstractmethod
    def get(self, key: str, default: Any = None) -> Any:
        """获取配置值"""
        pass

    @abstractmethod
    def set(self, key: str, value: Any) -> bool:
        """设置配置值"""
        pass

    @abstractmethod
    def save(self) -> bool:
        """保存配置"""
        pass

    @abstractmethod
    def load(self) -> bool:
        """加载配置"""
        pass

    @abstractmethod
    def get_all(self) -> Dict[str, Any]:
        """获取所有配置"""
        pass


class JsonConfigurationProvider(IConfigurationProvider):
    """JSON配置文件实现"""

    def __init__(self, config_path: str = "config.json"):
        self.config_path = config_path
        self.config = {}
        self.load()

    def get(self, key: str, default: Any = None) -> Any:
        keys = key.split('.')
        value = self.config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        return value

    def set(self, key: str, value: Any) -> bool:
        keys = key.split('.')
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
        return True

    def save(self) -> bool:
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"保存配置失败: {e}")
            return False

    def load(self) -> bool:
        try:
            if os.path.exists(self.config_path):
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    self.config = json.load(f)
                return True
            return False
        except Exception as e:
            print(f"加载配置失败: {e}")
            return False

    def get_all(self) -> Dict[str, Any]:
        return self.config.copy()
```

---

## 四、应用层架构

### 4.1 检测引擎

```python
class InspectionEngine:
    """检测引擎 - 核心业务逻辑"""

    def __init__(self):
        self.camera: IImageAcquisition = None
        self.preprocessing_pipeline = PreprocessingPipeline()
        self.algorithm_factory = DetectionAlgorithmFactory()
        self.storage: IDataStorage = None
        self.template: dict = None
        self.config = JsonConfigurationProvider()

    def initialize(self, config: dict):
        """初始化检测引擎"""
        # 配置相机
        camera_type = config.get('camera', {}).get('type', 'usb')
        self.camera = CameraFactory.create_camera(camera_type)

        # 配置存储
        storage_type = config.get('storage', {}).get('type', 'filesystem')
        storage_config = config.get('storage', {}).get('config', {})
        self.storage = StorageFactory.create_storage(storage_type, **storage_config)

        # 加载模板
        template_name = config.get('template', 'default')
        self.template = self.storage.get_template(template_name)

    def run_inspection(self) -> List[InspectionResult]:
        """执行检测流程"""
        results = []

        try:
            # 1. 采集图像
            image = self.camera.capture_image()
            if image is None:
                raise Exception("图像采集失败")

            # 2. 图像预处理
            processed_image = self.preprocessing_pipeline.process(image)

            # 3. 执行检测
            if self.template and 'features' in self.template:
                for feature_info in self.template['features']:
                    try:
                        # 获取检测算法
                        feature_type = FeatureType(feature_info['type'])
                        algorithm = self.algorithm_factory.get_algorithm(
                            feature_type.value,
                            feature_type
                        )

                        # 设置算法参数
                        algorithm.set_parameters(feature_info.get('parameters', {}))

                        # 执行检测
                        result = algorithm.detect(processed_image, feature_info)
                        results.append(result)

                    except Exception as e:
                        print(f"特征检测失败 {feature_info.get('id')}: {e}")

            # 4. 保存结果
            self.storage.save_inspection_batch(results)

            # 5. 保存图像（可选）
            image_id = f"inspection_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            self.storage.save_image(processed_image, image_id)

        except Exception as e:
            print(f"检测流程执行失败: {e}")

        return results

    def add_preprocessor(self, processor: IImagePreprocessor):
        """添加预处理器"""
        self.preprocessing_pipeline.add_processor(processor)

    def load_template(self, template_name: str) -> bool:
        """加载检测模板"""
        self.template = self.storage.get_template(template_name)
        return self.template is not None
```

---

## 五、事件系统

```python
from typing import Callable, Dict, List

class EventBus:
    """事件总线 - 实现组件间解耦"""

    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}

    def subscribe(self, event_type: str, handler: Callable):
        """订阅事件"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(handler)

    def unsubscribe(self, event_type: str, handler: Callable):
        """取消订阅"""
        if event_type in self.subscribers:
            if handler in self.subscribers[event_type]:
                self.subscribers[event_type].remove(handler)

    def publish(self, event_type: str, data: Any = None):
        """发布事件"""
        if event_type in self.subscribers:
            for handler in self.subscribers[event_type]:
                try:
                    handler(data)
                except Exception as e:
                    print(f"事件处理失败: {e}")


# 事件类型定义
class EventTypes:
    """事件类型常量"""
    IMAGE_CAPTURED = "image_captured"
    INSPECTION_STARTED = "inspection_started"
    INSPECTION_COMPLETED = "inspection_completed"
    INSPECTION_FAILED = "inspection_failed"
    RESULT_SAVED = "result_saved"
    CAMERA_CONNECTED = "camera_connected"
    CAMERA_DISCONNECTED = "camera_disconnected"
    # 未来可扩展更多事件类型


# 使用示例
event_bus = EventBus()

# 订阅事件
def on_inspection_completed(results):
    print(f"检测完成，共检测 {len(results)} 个特征")
    # 发送通知、更新UI等

event_bus.subscribe(EventTypes.INSPECTION_COMPLETED, on_inspection_completed)

# 发布事件
results = []
event_bus.publish(EventTypes.INSPECTION_COMPLETED, results)
```

---

## 六、API接口

```python
from flask import Flask, request, jsonify
from flask_cors import CORS
import threading

class InspectionAPI:
    """RESTful API接口"""

    def __init__(self, engine: InspectionEngine):
        self.app = Flask(__name__)
        CORS(self.app)
        self.engine = engine
        self._setup_routes()

    def _setup_routes(self):
        """设置API路由"""

        @self.app.route('/api/health', methods=['GET'])
        def health_check():
            """健康检查"""
            return jsonify({'status': 'ok', 'version': '1.0.0'})

        @self.app.route('/api/inspection/start', methods=['POST'])
        def start_inspection():
            """启动检测"""
            try:
                results = self.engine.run_inspection()
                return jsonify({
                    'success': True,
                    'results': [r.to_dict() for r in results]
                })
            except Exception as e:
                return jsonify({'success': False, 'error': str(e)}), 500

        @self.app.route('/api/camera/connect', methods=['POST'])
        def connect_camera():
            """连接相机"""
            device_id = request.json.get('device_id', '0')
            success = self.engine.camera.connect(device_id)
            return jsonify({'success': success})

        @self.app.route('/api/templates', methods=['GET'])
        def list_templates():
            """列出模板"""
            templates = self.engine.storage.list_templates()
            return jsonify({'templates': templates})

        @self.app.route('/api/templates/<template_name>', methods=['GET'])
        def get_template(template_name):
            """获取模板"""
            template = self.engine.storage.get_template(template_name)
            if template:
                return jsonify({'template': template})
            return jsonify({'error': 'Template not found'}), 404

        @self.app.route('/api/config', methods=['GET', 'POST'])
        def config():
            """获取/设置配置"""
            if request.method == 'GET':
                return jsonify(self.engine.config.get_all())
            else:
                data = request.json
                for key, value in data.items():
                    self.engine.config.set(key, value)
                self.engine.config.save()
                return jsonify({'success': True})

    def run(self, host='0.0.0.0', port=5000, threaded=True):
        """启动API服务器"""
        self.app.run(host=host, port=port, threaded=threaded)


# 在后台线程中运行API服务器
def start_api_server(engine: InspectionEngine):
    api = InspectionAPI(engine)
    api.run(host='0.0.0.0', port=5000)

# 使用示例
# engine = InspectionEngine()
# api_thread = threading.Thread(target=start_api_server, args=(engine,))
# api_thread.start()
```

---

## 七、扩展点总结

### 7.1 主要扩展点

| 扩展点 | 接口 | 用途 | 扩展方式 |
|--------|------|------|----------|
| 图像采集 | `IImageAcquisition` | 支持不同类型的相机 | 实现`IImageAcquisition`接口，通过`CameraFactory`注册 |
| 图像预处理 | `IImagePreprocessor` | 添加新的图像处理算法 | 实现`IImagePreprocessor`接口，添加到`PreprocessingPipeline` |
| 检测算法 | `IDetectionAlgorithm` | 添加新的检测算法 | 实现`IDetectionAlgorithm`接口，通过`DetectionAlgorithmFactory`注册 |
| 数据存储 | `IDataStorage` | 支持不同的存储方式 | 实现`IDataStorage`接口，通过`StorageFactory`注册 |
| 插件系统 | `IPlugin` | 添加自定义功能模块 | 实现`IPlugin`接口，通过`PluginManager`加载 |
| 特征类型 | `FeatureType`枚举 | 支持新的特征类型 | 扩展`FeatureType`枚举 |
| 配置提供者 | `IConfigurationProvider` | 支持不同的配置来源 | 实现`IConfigurationProvider`接口 |

### 7.2 扩展示例

```python
# 示例1：添加新的相机类型
class MyCustomCamera(IImageAcquisition):
    """自定义相机实现"""
    def connect(self, device_id: str) -> bool:
        # 实现连接逻辑
        pass

    # 实现其他接口方法...

# 注册相机类型
CameraFactory.register_camera_type('mycamera', MyCustomCamera)


# 示例2：添加新的检测算法
class MyCustomAlgorithm(BaseDetectionAlgorithm):
    """自定义检测算法"""
    def get_algorithm_name(self) -> str:
        return "My Custom Algorithm"

    def get_supported_features(self) -> List[FeatureType]:
        return [FeatureType.DIAMETER]

    def detect(self, image: np.ndarray, feature_info: dict) -> InspectionResult:
        # 实现检测逻辑
        pass

# 注册算法
DetectionAlgorithmFactory.register_algorithm('myalgo', MyCustomAlgorithm)


# 示例3：添加新的存储方式
class MyCustomStorage(IDataStorage):
    """自定义存储实现"""
    def save_inspection_result(self, result: InspectionResult) -> bool:
        # 实现保存逻辑
        pass

    # 实现其他接口方法...

# 注册存储类型
StorageFactory.register_storage_type('mystorage', MyCustomStorage)
```

---

## 八、最佳实践

### 8.1 版本兼容性

```python
class VersionManager:
    """版本管理器"""

    CURRENT_VERSION = "1.0.0"

    @staticmethod
    def check_compatibility(required_version: str) -> bool:
        """检查版本兼容性"""
        from packaging import version
        return version.parse(required_version) <= version.parse(VersionManager.CURRENT_VERSION)

    @staticmethod
    def get_version() -> str:
        """获取当前版本"""
        return VersionManager.CURRENT_VERSION
```

### 8.2 日志系统

```python
import logging
from logging.handlers import RotatingFileHandler

class LoggerFactory:
    """日志工厂"""

    @staticmethod
    def get_logger(name: str, log_file: str = "app.log"):
        """获取日志记录器"""
        logger = logging.getLogger(name)
        logger.setLevel(logging.DEBUG)

        # 文件处理器
        file_handler = RotatingFileHandler(
            log_file, maxBytes=10*1024*1024, backupCount=5
        )
        file_handler.setLevel(logging.DEBUG)

        # 控制台处理器
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)

        # 格式化器
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)

        # 添加处理器
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)

        return logger
```

### 8.3 错误处理

```python
class InspectionException(Exception):
    """检测异常基类"""
    pass

class CameraException(InspectionException):
    """相机异常"""
    pass

class AlgorithmException(InspectionException):
    """算法异常"""
    pass

class StorageException(InspectionException):
    """存储异常"""
    pass

# 使用装饰器进行错误处理
def handle_errors(func):
    """错误处理装饰器"""
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except CameraException as e:
            logger.error(f"相机错误: {e}")
            raise
        except AlgorithmException as e:
            logger.error(f"算法错误: {e}")
            raise
        except Exception as e:
            logger.error(f"未知错误: {e}")
            raise InspectionException(f"操作失败: {e}")
    return wrapper
```

---

## 九、总结

产品进化预留接口的核心要点：

1. **接口驱动设计**：定义清晰的抽象接口，所有实现都基于接口
2. **工厂模式**：使用工厂模式创建和管理实现类
3. **插件系统**：支持动态加载和卸载功能模块
4. **事件驱动**：通过事件总线实现组件间解耦
5. **配置管理**：支持灵活的配置和参数调整
6. **版本控制**：确保向后兼容性
7. **日志监控**：完善的日志和错误处理机制

通过以上设计，系统可以轻松扩展新的相机类型、检测算法、存储方式等功能，而无需修改核心代码，满足产品长期发展的需求。